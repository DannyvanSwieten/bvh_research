#version 450

struct Node{
    float min_x;
    float min_y;
    float min_z;
    float max_x;
    float max_y;
    float max_z;
    uint first_primitive;
    uint primitive_count;
};

struct Ray{
    vec3 origin;
    vec3 direction;
    vec3 invDirection;
};

layout(std430, set = 0, binding = 0) buffer BvhBuffer{
    Node nodes[];
} bvh;

layout(std430, set = 0, binding = 1) buffer VertexBuffer{
    vec3 vertices[];
} Vertices;

layout(std430, set = 0, binding = 2) buffer IndexBuffer{
    ivec3 indices[];
} Triangles;

layout(set = 0, binding = 3, rgba8) uniform image2D output_buffer;

#define FLOAT_MAX 100000

void swap_int(inout uint a, inout uint b){
    uint tmp = a;
    a = b;
    b = tmp;
}

void swap_float(inout float a, inout float b){
    float tmp = a;
    a = b;
    b = tmp;
}

float intersect_aabb(vec3 aabb_min, vec3 aabb_max, Ray ray, float t_far) {
    float tx1 = (aabb_min.x - ray.origin.x) * ray.invDirection.x;
    float tx2 = (aabb_max.x - ray.origin.x) * ray.invDirection.x;
    float ty1 = (aabb_min.y - ray.origin.y) * ray.invDirection.y;
    float ty2 = (aabb_max.y - ray.origin.y) * ray.invDirection.y;
    float tz1 = (aabb_min.z - ray.origin.z) * ray.invDirection.z;
    float tz2 = (aabb_max.z - ray.origin.z) * ray.invDirection.z;

    float tx_min = min(tx1, tx2);
    float tx_max = max(tx1, tx2);

    float ty_min = min(ty1, ty2);
    float ty_max = max(ty1, ty2);

    float tz_min = min(tz1, tz2);
    float tz_max = max(tz1, tz2);

    float t_min = max(tx_min, ty_min);
    float t_max = min(tx_max, ty_max);

    t_min = max(t_min, tz_min);
    t_max = min(t_max, tz_max);

    bool hit = t_max >= t_min && t_min < t_far && t_max > 0.0;
    if (hit) {
        return min(t_min, t_max);
    } else {
        return t_far;
    }
}

float intersect_triangle(Ray ray, vec3 v0, vec3 v1, vec3 v2)
{
    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    vec3 h = cross(ray.direction, edge2);
    float a = dot(edge1, h);
    // Assume faceculling is enabled.
    if (a < 0.0001) {
        // Ray is parallel to the triangle
        return FLOAT_MAX;
    }

    float f = 1.0 / a;
    vec3 s = ray.origin - v0;
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0) {
        return FLOAT_MAX;
    }
    vec3 q = cross(s, edge1);
    float v = f * dot(ray.direction, q);
    if (v < 0.0 || u + v > 1.0) {
        return FLOAT_MAX;
    }

    float t = f * dot(edge2, q);
    if (t < 0.000001) {
        return FLOAT_MAX;
    }

    return t;
}

float traverse(Ray ray)
{
    uint node_idx = 0;
    uint stack_ptr = 0;
    uint stack[64];
    float d = FLOAT_MAX;
    while(true) {
        Node node = bvh.nodes[node_idx];
        if (bvh.nodes[node_idx].primitive_count > 0) {
            uint first = node.first_primitive;
            uint last = first + node.primitive_count;
            for (uint p = first; p < last; ++p) {
                ivec3 triangle = Triangles.indices[p];
                float dl = intersect_triangle(
                    ray,
                    Vertices.vertices[triangle.x ].xyz,
                    Vertices.vertices[triangle.y ].xyz,
                    Vertices.vertices[triangle.z ].xyz
                );

                if (dl < d) {
                    d = dl;
                }
            }
            if (stack_ptr == 0) {
                break;
            } else {
                stack_ptr -= 1;
                node_idx = stack[stack_ptr];
                continue;
            }
        }

        uint left_child_idx = node.first_primitive ;
        uint right_child_idx = left_child_idx + 1;
        Node left_child = bvh.nodes[left_child_idx];
        Node right_child = bvh.nodes[right_child_idx];
        float left_distance = intersect_aabb(vec3(left_child.min_x, left_child.min_y, left_child.min_z), vec3(left_child.max_x, left_child.max_y, left_child.max_z), ray, FLOAT_MAX);
        float right_distance = intersect_aabb( vec3(right_child.min_x, right_child.min_y, right_child.min_z), vec3(right_child.max_x, right_child.max_y, right_child.max_z), ray, FLOAT_MAX);
        if (left_distance > right_distance) {
            swap_int(left_child_idx, right_child_idx);
            swap_float(left_distance, right_distance); 
        }
        if (left_distance == FLOAT_MAX) {
            if (stack_ptr == 0) {
                break;
            } else {
                stack_ptr -= 1;
                node_idx = stack[stack_ptr];
            }
        } else {
            node_idx = left_child_idx;
            if (right_distance != FLOAT_MAX) {
                stack[stack_ptr] = right_child_idx;
                stack_ptr += 1;
            }
        }
    }

    return d;
}

Ray create_ray(vec2 resolution, vec2 frag_location, vec3 origin, float z){
    vec2 norm = frag_location / resolution;
    vec3 p0 = vec3(-1, 1, z);
    vec3 p1 = vec3(1, 1, z);
    vec3 p2 = vec3(-1, -1, z);

    vec3 pixel_position = 
            p0
            + (p1 - p0) * norm.x
            + (p2 - p0) * norm.y;

    vec3 direction = normalize(pixel_position - origin);
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.invDirection = 1.0 / direction;
    return ray;
}

void main(){
    Ray ray = create_ray(vec2(640, 640), vec2(gl_GlobalInvocationID.xy), vec3(-5, 0, -15), 2);
    float d = traverse(ray);
    if(d < FLOAT_MAX)
        imageStore(output_buffer, ivec2(gl_GlobalInvocationID.xy), vec4(1));
}