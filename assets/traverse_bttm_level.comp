#version 460

struct Node{
    float min_x;
    float min_y;
    float min_z;
    float max_x;
    float max_y;
    float max_z;
    int first_primitive;
    int primitive_count;
};

struct Ray{
    vec3 origin;
    vec3 direction;
};

layout(std430, set = 0, binding = 0) buffer BvhBuffer{
    Node nodes[];
} bvh;

layout(set = 0, binding = 1) buffer VertexBuffer{
    vec4 vertices[];
} Vertices;

layout(set = 0, binding = 2) buffer IndexBuffer{
    ivec4 indices[];
} Triangles;

layout(set = 0, binding = 3, rgba8) uniform image2D output_buffer;

#define FLOAT_MAX 10000000

void swap_int(out int a, out int b){
    int tmp = a;
    a = b;
    b = tmp;
}

void swap_float(out float a, out float b){
    float tmp = a;
    a = b;
    b = tmp;
}

float intersect_aabb(vec3 aabb_min, vec3 aabb_max, Ray ray, float t_far) {
    float tx1 = (aabb_min.x - ray.origin.x) / ray.direction.x;
    float tx2 = (aabb_max.x - ray.origin.x) / ray.direction.x;
    float ty1 = (aabb_min.y - ray.origin.y) / ray.direction.y;
    float ty2 = (aabb_max.y - ray.origin.y) / ray.direction.y;
    float tz1 = (aabb_min.z - ray.origin.z) / ray.direction.z;
    float tz2 = (aabb_max.z - ray.origin.z) / ray.direction.z;

    float t_min = min(tx1, tx2);
    float t_max = max(tx1, tx2);

    t_min = max(t_min, min(ty1, ty2));
    t_max = min(t_max, max(ty1, ty2));

    t_min = max(t_min, min(tz1, tz2));
    t_max = min(t_max, max(tz1, tz2));

    bool hit = t_max >= t_min && t_min < t_far && t_max > 0.0;
    if (hit) {
        return min(t_min, t_max);
    } else {
        return t_far;
    }
}

float intersect_triangle(Ray ray, vec3 v0, vec3 v1, vec3 v2)
{
    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    vec3 h = cross(ray.direction, edge2);
    float a = dot(edge1, h);
    if (a > -0.0001 && a < 0.0001) {
        // Ray is parallel to the triangle
        return FLOAT_MAX;
    }

    float f = 1.0 / a;
    vec3 s = ray.origin - v0;
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0) {
        return FLOAT_MAX;
    }
    vec3 q = cross(s, edge1);
    float v = f * dot(ray.direction, q);
    if (v < 0.0 || u + v > 1.0) {
        return FLOAT_MAX;
    }

    float t = f * dot(edge2, q);
    if (t < 0.000001) {
        return FLOAT_MAX;
    }

    return t;
}

float traverse(Ray ray)
{
    int node_idx = 0;
    int stack_ptr = 0;
    int stack[64];
    float d = FLOAT_MAX;
    while(true) {
        Node node = bvh.nodes[node_idx];
        if (bvh.nodes[node_idx].primitive_count > 0) {
            int first = node.first_primitive;
            int last = first + node.primitive_count;
            return 1.0;
            for (int p = first; p < last; ++p) {
                ivec4 triangle = Triangles.indices[p];
                float dl = intersect_triangle(
                    ray,
                    Vertices.vertices[triangle.x ].xyz,
                    Vertices.vertices[triangle.y ].xyz,
                    Vertices.vertices[triangle.z ].xyz
                );

                if (dl < d) {
                    d = dl;
                }
            }
            if (stack_ptr == 0) {
                break;
            } else {
                stack_ptr -= 1;
                node_idx = stack[stack_ptr];
                continue;
            }
        }

        int left_child_idx = node.first_primitive ;
        int right_child_idx = left_child_idx + 1;
        Node left_child = bvh.nodes[left_child_idx];
        Node right_child = bvh.nodes[right_child_idx];
        float left_distance = intersect_aabb(vec3(left_child.min_x, left_child.min_y, left_child.min_z), vec3(left_child.max_x, left_child.max_y, left_child.max_z), ray, FLOAT_MAX);
        float right_distance = intersect_aabb( vec3(right_child.min_x, right_child.min_y, right_child.min_z), vec3(right_child.max_x, right_child.max_y, right_child.max_z), ray, FLOAT_MAX);
        if (left_distance > right_distance) {
            swap_int(left_child_idx, right_child_idx);
            swap_float(left_distance, right_distance);        
        }
        if (left_distance == FLOAT_MAX) {
            if (stack_ptr == 0) {
                break;
            } else {
                stack_ptr -= 1;
                node_idx = stack[stack_ptr];
            }
        } else {
            node_idx = left_child_idx;
            if (right_distance != FLOAT_MAX) {
                stack[stack_ptr] = right_child_idx;
                stack_ptr += 1;
            }
        }
    }

    return d;
}

Ray create_ray(vec2 resolution, vec2 frag_location, vec3 origin, float z){
    vec2 norm = frag_location / resolution;
    vec3 p0 = vec3(-1, 1, z);
    vec3 p1 = vec3(1, 1, z);
    vec3 p2 = vec3(-1, -1, z);

    vec3 pixel_position = 
            p0
            + (p1 - p0) * norm.x
            + (p2 - p0) * norm.y;

    vec3 direction = normalize(pixel_position - origin);
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

void main(){
    if(gl_GlobalInvocationID.x > 639 || gl_GlobalInvocationID.y > 639)
        return;
        
    Ray ray = create_ray(vec2(640, 640), vec2(gl_GlobalInvocationID.xy), vec3(-5, 0, -5), 2);
    float d = traverse(ray);
    if(d < FLOAT_MAX)
        imageStore(output_buffer, ivec2(gl_GlobalInvocationID.xy), vec4(1));
}